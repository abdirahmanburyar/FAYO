import {
  Injectable,
  NotFoundException,
  BadRequestException,
  Logger,
} from '@nestjs/common';
import { PrismaService } from '../common/database/prisma.service';
import { AgoraService } from '../agora/agora.service';
import { CreateCallDto } from './dto/create-call.dto';
import { RabbitMQService } from '../rabbitmq/rabbitmq.service';
import { AppointmentGateway } from '../websocket/appointment.gateway';

@Injectable()
export class CallsService {
  private readonly logger = new Logger(CallsService.name);

  constructor(
    private readonly prisma: PrismaService,
    private readonly agoraService: AgoraService,
    private readonly rabbitMQService: RabbitMQService,
    private readonly appointmentGateway: AppointmentGateway,
  ) {}

  /**
   * Create a video call session for an appointment
   * @param createCallDto - Call creation data
   * @returns Call credentials for the initiator
   */
  async createCall(createCallDto: CreateCallDto) {
    try {
      this.logger.log(
        `üìû [CALL] Creating video call for appointment: ${createCallDto.appointmentId}`,
      );

      // 1. Validate appointment exists and is a VIDEO appointment
      const appointment = await this.prisma.appointment.findUnique({
        where: { id: createCallDto.appointmentId },
      });

      if (!appointment) {
        throw new NotFoundException(
          `Appointment with ID ${createCallDto.appointmentId} not found`,
        );
      }

      if (appointment.consultationType !== 'VIDEO') {
        throw new BadRequestException(
          'Video calls can only be created for VIDEO consultation type appointments',
        );
      }

      if (appointment.status === 'CANCELLED' || appointment.status === 'COMPLETED') {
        throw new BadRequestException(
          `Cannot create call for ${appointment.status.toLowerCase()} appointment`,
        );
      }

      // 2. Generate unique channel name
      const channelName = `appointment-${appointment.id}-${Date.now()}`;

      // Validate channel name
      if (!this.agoraService.validateChannelName(channelName)) {
        throw new BadRequestException('Invalid channel name format');
      }

      // 3. Generate user IDs (0 for auto-generated, or use specific IDs)
      const hostUid = 0; // Auto-generated by Agora
      const participantUid = 0; // Auto-generated by Agora

      // 4. Generate Agora credentials for both HOST (publisher) and PARTICIPANT (subscriber)
      const credentials = await this.agoraService.generateCallCredentials(
        channelName,
        hostUid,
        participantUid,
      );

      // 5. Create call session record (optional - for tracking)
      // You can store this in a separate calls table if needed
      const callSession = {
        id: `call-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
        appointmentId: appointment.id,
        channelName,
        hostUid,
        participantUid,
        status: 'ACTIVE',
        createdAt: new Date().toISOString(),
      };

      // 6. Publish call.created event to Kafka, RabbitMQ, and WebSocket
      await this.publishCallCreatedEvent(callSession, credentials);
      
      // 7. Broadcast call invitation via WebSocket to patient
      this.appointmentGateway.broadcastCallInvitation({
        appointmentId: appointment.id,
        patientId: appointment.patientId,
        channelName,
        callSession,
        credentials: {
          appId: credentials.participant.appId,
          token: credentials.participant.token,
          channelName: credentials.participant.channelName,
          uid: String(credentials.participant.uid), // Convert to string for mobile app
          role: 'AUDIENCE',
          expiresAt: credentials.participant.expiresAt,
          expiresIn: credentials.participant.expiresIn,
        },
      });

      this.logger.log(
        `‚úÖ [CALL] Video call session created: ${channelName} for appointment: ${appointment.id}`,
      );

      // 7. Return HOST credentials (for the admin initiating the call)
      return {
        session: callSession,
        credential: {
          appId: credentials.host.appId,
          token: credentials.host.token,
          channelName: credentials.host.channelName,
          uid: credentials.host.uid,
          role: 'HOST' as const,
          expiresAt: credentials.host.expiresAt,
          expiresIn: credentials.host.expiresIn,
        },
      };
    } catch (error) {
      this.logger.error(`‚ùå [CALL] Error creating call:`, error);
      if (
        error instanceof NotFoundException ||
        error instanceof BadRequestException
      ) {
        throw error;
      }
      throw new BadRequestException(
        `Failed to create video call: ${error instanceof Error ? error.message : 'Unknown error'}`,
      );
    }
  }

  /**
   * Get call credentials for a participant (patient)
   * @param appointmentId - Appointment ID
   * @param userId - Patient user ID
   * @returns Call credentials for PARTICIPANT
   */
  async getParticipantCredentials(appointmentId: string, userId: string) {
    try {
      this.logger.log(
        `üìû [CALL] Getting participant credentials for appointment: ${appointmentId}, user: ${userId}`,
      );

      // 1. Validate appointment exists
      const appointment = await this.prisma.appointment.findUnique({
        where: { id: appointmentId },
      });

      if (!appointment) {
        throw new NotFoundException(
          `Appointment with ID ${appointmentId} not found`,
        );
      }

      // 2. Verify user is the patient
      if (appointment.patientId !== userId) {
        throw new BadRequestException(
          'User is not authorized to join this call',
        );
      }

      // 3. Generate channel name (should match the one used when call was created)
      // In a real scenario, you might store the channel name in a calls table
      // For now, we'll use a consistent naming pattern
      const channelName = `appointment-${appointment.id}`;

      // 4. Generate PARTICIPANT credentials (subscriber role)
      const participantUid = 0; // Auto-generated by Agora
      const credential = await this.agoraService.generateRtcToken(
        channelName,
        participantUid,
        'subscriber', // PARTICIPANT role
      );

      this.logger.log(
        `‚úÖ [CALL] Participant credentials generated for appointment: ${appointmentId}`,
      );

      return {
        credential: {
          appId: credential.appId,
          token: credential.token,
          channelName: credential.channelName,
          uid: credential.uid,
          role: 'AUDIENCE' as const,
          expiresAt: credential.expiresAt,
          expiresIn: credential.expiresIn,
        },
      };
    } catch (error) {
      this.logger.error(`‚ùå [CALL] Error getting participant credentials:`, error);
      if (
        error instanceof NotFoundException ||
        error instanceof BadRequestException
      ) {
        throw error;
      }
      throw new BadRequestException(
        `Failed to get participant credentials: ${error instanceof Error ? error.message : 'Unknown error'}`,
      );
    }
  }

  /**
   * End a call session
   * @param appointmentId - Appointment ID
   * @param userId - User ID ending the call
   */
  async endCall(appointmentId: string, userId: string) {
    try {
      this.logger.log(
        `üìû [CALL] Ending call for appointment: ${appointmentId}, user: ${userId}`,
      );

      // Validate appointment exists
      const appointment = await this.prisma.appointment.findUnique({
        where: { id: appointmentId },
      });

      if (!appointment) {
        throw new NotFoundException(
          `Appointment with ID ${appointmentId} not found`,
        );
      }

      // Publish call.ended event
      await this.publishCallEndedEvent(appointmentId, userId);

      this.logger.log(
        `‚úÖ [CALL] Call ended for appointment: ${appointmentId}`,
      );

      return {
        success: true,
        message: 'Call ended successfully',
        appointmentId,
      };
    } catch (error) {
      this.logger.error(`‚ùå [CALL] Error ending call:`, error);
      if (error instanceof NotFoundException) {
        throw error;
      }
      throw new BadRequestException(
        `Failed to end call: ${error instanceof Error ? error.message : 'Unknown error'}`,
      );
    }
  }

  /**
   * Publish call.created event via WebSocket and RabbitMQ
   */
  private async publishCallCreatedEvent(callSession: any, credentials: any) {
    try {
      const event = {
        type: 'call.created',
        callSession,
        credentials: {
          host: credentials.host,
          participant: credentials.participant,
        },
        timestamp: new Date().toISOString(),
      };

      // Broadcast via WebSocket (replaces Kafka)
      this.appointmentGateway.broadcastCallCreated(callSession);

      // Publish to RabbitMQ for async processing
      await this.rabbitMQService.publishCallCreated(event);

      this.logger.log('üì§ [CALL] Published call.created event via WebSocket and RabbitMQ');
    } catch (error) {
      this.logger.error('‚ùå [CALL] Error publishing call.created event:', error);
      // Don't throw - event publishing failure shouldn't fail call creation
    }
  }

  /**
   * Publish call.ended event via WebSocket and RabbitMQ
   */
  private async publishCallEndedEvent(appointmentId: string, userId: string) {
    try {
      const event = {
        type: 'call.ended',
        appointmentId,
        endedBy: userId,
        timestamp: new Date().toISOString(),
      };

      // Get call session for WebSocket broadcast
      const callSession = await this.prisma.callSession.findFirst({
        where: { appointmentId, status: { not: 'ENDED' } },
        orderBy: { createdAt: 'desc' },
      });

      if (callSession) {
        // Broadcast via WebSocket (replaces Kafka)
        this.appointmentGateway.broadcastCallEnded(callSession);
      }

      // Publish to RabbitMQ for async processing
      await this.rabbitMQService.publishCallEnded(event);

      this.logger.log('üì§ [CALL] Published call.ended event via WebSocket and RabbitMQ');
    } catch (error) {
      this.logger.error('‚ùå [CALL] Error publishing call.ended event:', error);
      // Don't throw - event publishing failure shouldn't fail call ending
    }
  }

  /**
   * Accept a call invitation (called by patient)
   * @param appointmentId - Appointment ID
   * @param patientId - Patient ID
   * @param channelName - Agora channel name
   */
  async acceptCall(appointmentId: string, patientId: string, channelName: string) {
    try {
      this.logger.log(
        `üìû [CALL] Patient ${patientId} accepted call for appointment: ${appointmentId}`,
      );

      // Validate appointment exists
      const appointment = await this.prisma.appointment.findUnique({
        where: { id: appointmentId },
      });

      if (!appointment) {
        throw new NotFoundException(
          `Appointment with ID ${appointmentId} not found`,
        );
      }

      if (appointment.patientId !== patientId) {
        throw new BadRequestException(
          'Patient ID does not match appointment patient',
        );
      }

      // Broadcast call.accepted event via WebSocket
      this.appointmentGateway.broadcastCallAccepted({
        appointmentId,
        channelName,
        patientId,
      });

      this.logger.log(
        `‚úÖ [CALL] Call accepted event broadcasted for appointment: ${appointmentId}`,
      );

      return {
        success: true,
        message: 'Call accepted successfully',
        appointmentId,
        channelName,
      };
    } catch (error) {
      this.logger.error(`‚ùå [CALL] Error accepting call:`, error);
      throw error;
    }
  }
}

